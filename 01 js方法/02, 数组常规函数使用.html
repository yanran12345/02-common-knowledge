<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  
</body>
<script>
 //. map  不改变原数组，返回一个新的数组
  const arr = [1, 'a', 2]
  const newarr = arr.map((value, index, array) => {
    return value +"h"
  })
  console.log(newarr);

//. filter()
const arr = [45, 4, 9, 16, 25];
   console.log(arr.filter((value) => {
        return value > 18;
    })) //[45, 25]

//. reduce() 
const arr = [1, 2, 3, 4, 5]
const brr = arr.reduce((a, b) => a+b, 0)
console.log(brr) //15

//. some()
// 不创建新数组、不改变原数组、判断为true则马上return true，否则return false；
  let arr = [1,2,3,4,5];
  let result1 = arr.some((item)=> {
      return item > 2 && item < 4;
  });
  let result2 = arr.some((item)=>{
      return item > 5;
  });
  console.log(result1);  // 输出ture
  console.log(result2);  // 输出false

//. every()
// 不创建新数组、不改变原数组、判断为false则马上return false，否则return true;
  let arr = [1,2,3,4,5];
  let result1 = arr.every((item)=> {
      return item > 2;
  });
  let result2 = arr.every((item)=>{
      return item < 6;
  });
  console.log(result1);  // 输出false
  console.log(result2);  // 输出true

//. for...in
// 循环：可以把一个对象的所有属性依次循环出来,循环得到的是String而不是Number
  //对象
  var o ={
      name:"jack",
      age:20,
      city:"beijing"
  };
  for (var key in o){
        alert(key)  //"name","age","city"
  } 
  //数组
  var a =["A","B","C"];
  for (var i in a){
      alert(i);       //"0","1","2"
      alert(a[i]);   //"A","B","C"
  }

//. for...of
// ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型；具有iterable类型的集合可以通过for...of循环来遍历
  var a = ["A","B","C"];
  var s = new Set(["A","B","C"]);
  var m = new Map([[1,"x"],[2,"y"],[3,"z"]]);
  for (var x of a){
      alert(x);
  }
  for (var x of s){
      alert(x);
  }
  for (var x of m){
      alert(x[0]+"="+x[1]);
  }
//. forEach
  // 在ES5中 forEach  ，缺点：无法使用 break 语句跳出循环，或者使用 return 从函数体内返回。
  var a = [1,2,3,9,4,5,8,]
  a.forEach((item)=> {
    if(item === 3) break;
    console.log(item)  //报错
  })

  var b = [1,3,5,6,2]
  b.forEach((item)=> {
    if(item === 3) return;
    console.log(item)  //1 5 6 2
  })



//. indexOf()
//找到函数则停止运行 从左往右
const arr = [1,2,3,5,4,3,6,4];
console.log(arr.indexOf(3)); //2
console.log(arr.indexOf(3,2)); //2
console.log(arr.indexOf("4")); //-1
console.log(arr.indexOf(4,3)); //4

//. lastIndexOf()
//找到函数则停止运行 从右往左
const arr = [1,2,3,5,4,3,6,4];
console.log(arr.lastIndexOf(3)); //5
console.log(arr.lastIndexOf(3,2)); //2
console.log(arr.lastIndexOf("4")); //-1
console.log(arr.lastIndexOf(4,6)); //4

//. findIndex()
const arr = [1, 2, 3, 4, 5, 6]
    const brr = arr.findIndex((value, index, arr) => {
        return value > 3 //3
        // return value <-2  打印-1    
      })
    console.log(brr) // 3

//fill() 
// 语法：arr.fill(value, start, end)
// value：填充值。
// start：填充起始位置，可以省略。
// end：填充结束位置，可以省略，实际结束位置是end-1
// 无起止位置
  const arr = [1, 2, 3, 4, 5]
  arr.fill(7)
  console.log(arr) //[7, 7, 7, 7, 7]
// 有开始位置
    const arr = [1, 2, 3, 4, 5]
    arr.fill(8, 2)
    console.log(arr) // [1, 2, 8, 8, 8]
// 有起止位置
    const arr = [1, 2, 3, 4, 5]
    arr.fill(8, 2, 3)
    console.log(arr) //  [1, 2, 8, 4, 5]

//includes()
// arr.includes(searchElement, fromIndex)
// searchElement：必须。需要查找的元素值。
// fromIndex：可选。表示判断的起始位置。从该索引处开始查找 searchElement。
const arr = [1, 'a', 'cj', NaN];
  console.log(arr.includes("a"));//true
  console.log(arr.includes(NaN));//true
  console.log(arr.includes("a", 0));//true
  console.log(arr.includes("a", 2));//false
</script>
</html>